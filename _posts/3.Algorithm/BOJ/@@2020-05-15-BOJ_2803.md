---
title: "BOJ 2803 : 내가 어렸을 때 가지고 놀던 장난감"
excerpt: "분할 정복/비트마스크/조합론/포함-배제의 원리"

categories:
- Algorithm

tags:
- BOJ
---

> 시작하면서

 이번 문제는 **분할 정복** 카테고리 문제이다.

[BOJ 2803 - 내가 어렸을 때 가지고 놀던 장난감](https://www.acmicpc.net/problem/2803)    

​    

> 개념

 이 문제에는 총 4가지 개념 카테고리가 달려 있다.

- 분할 정복
- 비트마스크
- 조합론
- 포함-배제의 원리

간단하게나마 하나씩 살펴보겠다.    

​    

1. **분할 정복 (Divide and Conquer)**

   - 개념
     - 분할 정복은 기본적으로 엄청나게 크고 방대한 문제를 조금씩 조금씩 나눠가면서 용이하게 풀 수 있는 문제 단위로 나눈 다음 그것들을 다시 합쳐서 해결하자는 개념에서 출발했다. 대표적으로는 퀵소트와 합병 정렬이 있다.
   - 장점
     - 문제를 나눔으로써 어려운 문제를 해결할 수 있다. 문제를 나누어 해결한다는 특징상 병렬적으로 문제를 해결하는 데 큰 강점이 있다.
   - 단점
     - 함수를 재귀적으로 호출한다는 점에서 함수 호출로 인한 오버헤드가 발생하며, 스택에 다양한 데이터를 보관하고 있어야 하므로 스택 오버플로우가 발생하거나 과도한 메모리 사용을 하게 되는 단점이 있다.
       

2. **비트마스크 (Bitmask)**

   - 개념
     - 컴퓨터 과학에서 마스크(mask) 또는 비트마스크(bitmask)는 특히 비트 필드에서 비트 연산에 사용되는 데이터이다.
     - 용어 그대로 비트(bit)에 관련된 것이다. 비트는 이진 숫자(binary digit)를 뜻하는 말로 컴퓨터에서 사용되는 데이터의 최소 단위이다. 비트는 0, 1의 값을 가질 수 있다.
       

3. **조합론 (Combinatorics)**

   - 개념
     - 조합론 또는 조합수학은 유한하거나 가산적인 구조들에 대하여, 어떤 주어진 성질을 만족시키는 것들의 가짓수나 어떤 주어진 성질을 극대화하는 것을 연구하는 수학 분야이다.
   - 분류
     - 순열(Permutation) : 서로 다른 n개의 원소에서 r개를 뽑아 한 줄로 세우는 경우의 수. [nPr]
     - 조합(Combination) : 집합에서 서로 다른 n개의 원소 중에서 순서에 상관없이 r개를 선택하는 경우의 수 [nCr]
     - 집합의 분할 : 집합의 원소들을 비공(non-empty) 부분집합들에게 나눠주어, 모든 원소가 각자 정확히 하나의 부분집합에 속하게끔 하는 것이다.
     - 문자열(word)
     - 부분 순서 집합 : 순서로 생각할 수 있는 관계를 부여한 집합이며, 특수한 경우로 전순서 집합이나 격자 등이 있다.
     - 그래프 : 일련의 꼭짓점들과 이들 사이를 잇는 변들로 구성된 조합론적 구조이다.
     - 매트로이드 : 그래프를 일반화한 개념
     - 유한 기하(finite geometry) : 유한한 수의 점과 선 등으로 구성된 기하학적 공간이다.
       

4. **포함-배제의 원리 (Inclusion-Exclusion principle)**

   - 개념

     - 유한 집합의 합집합의 원소 개수를 세는 기법이다.

     - [자세한 내용을 언급하기에는 그림도 그려야하고 식이 많으므로 링크로 대체한다]([https://namu.wiki/w/%ED%8F%AC%ED%95%A8%C2%B7%EB%B0%B0%EC%A0%9C%EC%9D%98%20%EC%9B%90%EB%A6%AC](https://namu.wiki/w/포함·배제의 원리))    

​    

​    

> 문제 이해

 문제를 읽어보자. 먼저 이 문제에서 나오는 변수의 종류는 총 3가지이다.

- N ( 1<= N <= 1,000,000) : 장난감 상자 개수
- M ( 1 <= M <= 20) : 장난감 종류
- Ki ( 0 <= Ki <= M) : 장난감 종류의 수

 이 변수들을 가지고 답을 출력해야한다. 다음은 예제로 문제를 이해해보자.

## 예제 입력 1

```
  |3 3
A |3 1 2 3
B |3 1 2 3
C |3 1 2 3
```

 글을 쓰기 쉽게 임의로 각 박스에 알파벳으로 네이밍을 해두었다. 모든 종류의 장난감이 들어있게 박스를 고르는 방법의 수는 다음과 같다.

```
A / B / C / A B / A C / B C / A B C ==> 7가지
```

 좀 더 이해하기 위해 하나 더 보자.

## 예제 입력 3

```
  |4 5
A |2 2 3
B |2 1 2
C |4 1 2 3 5
D |4 1 2 4 5
```

 모든 종류의 장난감이 들어있게 박스를 고르기 위해서는 유일하게 4가 들어있는 D는 무조건 들어가야 한다.
또한, D가 무조건 들어가야 하므로 D에 없는 3이 무조건 들어가야 한다.

```
D A / D A B // D C / D C B // D C A / D C A B ==> 6가지
```

​    

​    

​    

> 문제 아이디어

 나는 시작할 때 이렇게 생각했다.

1) 무조건 들어가야하는 집합을 찾는다. (유일한 종류의 장난감을 가지고 있는 집합)

2) bool array\[N][M]은 비효율적이니 int array[N] 으로 비트마스크를 사용한다.

3) 모든 경우의 수를 다 해보려면 nCr + nCr-1 + ... + nC2 + nC1 = 2^n -1 의 경우의 수가 발생한다. 너무 많아서 다 해보는건 비효율적이다.

4) 문제가 분할 정복 문제인만큼 작게 쪼개서 문제를 풀어야겠다.



----

----

여기까지.... 이 이상 못함 ㅅㄱ

 https://booknu.github.io/2019/04/24/BOJ2803/ 